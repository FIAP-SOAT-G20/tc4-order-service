name: ci/coverage

on:
  pull_request:
    types: [opened, reopened, synchronize]

permissions:
  contents: write
  pull-requests: write

jobs:
  go-test-coverage:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version:
          - "1.24"

    steps:
      - uses: actions/checkout@v3

      - name: "Setup Go ${{ matrix.go-version }}"
        uses: actions/setup-go@v3
        with:
          go-version: "${{ matrix.go-version }}"
          cache: true

      - name: Display Go version
        run: go version

      - name: generate test coverage
        run: go test -json -timeout 1m -race ./... -coverprofile=./cover.out -covermode=atomic -coverpkg=./...
      
      - name: check test coverage
        id: coverage
        uses: vladopajic/go-test-coverage@v2
        continue-on-error: true # Should fail after coverage comment is posted
        with:
          config: ./.github/.testcoverage.yml
          # git-token: ${{ github.ref_name == 'main' && secrets.GITHUB_TOKEN || '' }}
          # git-branch: badges

      - name: ðŸ“Š Upload coverage artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: |
            cover.out
            coverage.out
            .github/.testcoverage.yml
          retention-days: 7

      # Generate enhanced coverage report
      - name: ðŸ“‹ Generate coverage summary
        if: always()
        id: coverage-summary
        run: |
          # Determine coverage status based on coverage check step outcome
          if [ "${{ steps.coverage.outcome }}" = "success" ]; then
            COVERAGE_STATUS="âœ… PASSED"
            STATUS_ICON="âœ…"
            COVERAGE_RESULT="Coverage requirements met"
          else
            COVERAGE_STATUS="âŒ FAILED"
            STATUS_ICON="âŒ"
            COVERAGE_RESULT="Coverage requirements not met"
          fi
          
          # Extract coverage percentage from report if available
          COVERAGE_REPORT="${{ fromJSON(steps.coverage.outputs.report) }}"
          
          # Create enhanced coverage summary
          cat > coverage_summary.md << EOF
          ## ðŸ“Š Test Coverage Report
          
          **Status:** $COVERAGE_STATUS  
          **Result:** $COVERAGE_RESULT
          
          ### ðŸŽ¯ Coverage Details:
          \`\`\`
          $COVERAGE_REPORT
          \`\`\`
          
          ### ï¿½ Coverage Requirements:
          - **Minimum Threshold:** 80%
          - **Coverage Profile:** ./cover.out
          - **Coverage Mode:** atomic
          
          ### ðŸ”§ Test Configuration:
          - **Go Version:** ${{ matrix.go-version }}
          - **Race Detection:** âœ… enabled
          - **Timeout:** 1 minute
          - **Test Packages:** All packages (./...)
          
          ### ï¿½ Excluded from Coverage:
          - Mock files (\`*_mock.go\`)
          - Request/Response DTOs (\`*_request.go\`, \`*_response.go\`)
          - Infrastructure adapters (\`*_gateway.go\`, \`*_datasource.go\`, \`*_presenter.go\`)
          - Documentation and configuration files
          - Value objects and domain entities
          
          ---
          _Automated test coverage ensures code quality and identifies untested business logic._
          EOF
          
          # Also add to step summary
          cat coverage_summary.md >> $GITHUB_STEP_SUMMARY
          
          # Set output for PR comment
          echo "SUMMARY_CONTENT<<EOF" >> $GITHUB_OUTPUT
          cat coverage_summary.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: ðŸ’¬ Comment coverage report on PR
        if: always() && github.event_name == 'pull_request'
        uses: thollander/actions-comment-pull-request@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          comment-tag: coverage-report
          message: ${{ steps.coverage-summary.outputs.SUMMARY_CONTENT }}
            

      - name: "finally check coverage"
        if: steps.coverage.outcome == 'failure'
        shell: bash
        run: echo "coverage check failed" && exit 1
